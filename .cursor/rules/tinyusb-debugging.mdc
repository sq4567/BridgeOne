---
title: "TinyUSB 디버깅 및 문제 해결 규칙"
description: "ESP-IDF 환경에서 TinyUSB 개발 시 발생하는 일반적인 빌드 오류, 런타임 문제, 디버깅 방법에 대한 해결책과 가이드를 제공합니다."
tags: ["tinyusb", "esp-idf", "debug", "troubleshooting", "hid", "cdc"]
version: "v1.0"
owner: "Chatterbones"
updated: "2025-10-31"
framework: "ESP-IDF + TinyUSB"
references: ["Context7:/hathach/tinyusb", "mdc:./tinyusb-architecture.mdc", "mdc:./tinyusb-descriptors.mdc"]
---

# TinyUSB 디버깅 및 문제 해결 규칙

> **규칙 목적**: 개발 과정에서 발생하는 예측 가능한 문제들을 표준화된 절차에 따라 신속하게 해결하여 개발 효율성을 높입니다.

---

## 1. 일반적인 빌드 오류

### 1.1. `undefined reference to tud_descriptor_..._cb`

**원인**: 필수 디스크립터 콜백 함수가 애플리케이션에 구현되지 않았습니다.
- `tud_descriptor_device_cb`
- `tud_descriptor_configuration_cb`
- `tud_descriptor_string_cb`
- `tud_hid_descriptor_report_cb`

**해결책**:
1.  `src/board/BridgeOne/main/usb_descriptors.c` 파일에 누락된 콜백 함수를 모두 구현합니다.
2.  `main/CMakeLists.txt`의 `SRCS` 목록에 `usb_descriptors.c`가 포함되어 있는지 확인합니다.
3.  자세한 구현 방법은 `mdc:./tinyusb-descriptors.mdc` 문서를 참조하십시오.

### 1.2. `undefined reference to tud_hid_n_...` 또는 `tud_cdc_n_...`

**원인**: 소스 파일 상단에 `"tusb.h"` 헤더 파일이 포함되지 않았거나, `CMakeLists.txt`에 TinyUSB 컴포넌트 의존성이 누락되었습니다.

**해결책**:
1.  API를 사용하는 모든 `.c` 파일 상단에 `#include "tusb.h"`를 추가합니다.
2.  `main/CMakeLists.txt` 파일의 `idf_component_register`에 `REQUIRES espressif__tinyusb`가 포함되어 있는지 확인합니다.

---

## 2. 런타임 디버깅

### 2.1. TinyUSB 디버그 로그 활성화

TinyUSB 내부 동작을 확인하는 가장 효과적인 방법은 내장된 로그 기능을 활성화하는 것입니다.

**`sdkconfig` 설정**:
```ini
# idf.py menuconfig -> Component config -> TinyUSB Stack
CONFIG_TINYUSB_DEBUG_LEVEL=3

# idf.py menuconfig -> Component config -> Log output
CONFIG_LOG_DEFAULT_LEVEL_INFO=n
CONFIG_LOG_DEFAULT_LEVEL_DEBUG=y
```
- `CONFIG_TINYUSB_DEBUG_LEVEL`: 3(Info)으로 설정하면 USB 열거 과정의 상세한 로그를 볼 수 있습니다.
- `CONFIG_LOG_DEFAULT_LEVEL_DEBUG`: ESP-IDF의 전역 로그 레벨을 DEBUG로 설정해야 TinyUSB 로그가 출력됩니다.

**출력 예시**:
```
I (1234) TinyUSB: tud_init(0)
I (1240) TinyUSB: Bus reset
I (1350) TinyUSB: Set address: 5
I (1360) TinyUSB: Get descriptor: Device
I (1370) TinyUSB: Get descriptor: Configuration
```

### 2.2. USB 열거 실패 (Windows "알 수 없는 장치")

**원인**: 디스크립터, 특히 Configuration Descriptor의 내용이나 길이가 잘못되었을 가능성이 높습니다.

**디버깅 절차**:
1.  **디스크립터 길이 검증**: `CONFIG_TOTAL_LEN` 매크로 값이 실제 `desc_configuration` 배열의 크기와 일치하는지 확인합니다.
    ```c
    // 디버깅 코드 예시
    ESP_LOGI("DESC", "Expected size: %d, Actual size: %d", CONFIG_TOTAL_LEN, sizeof(desc_configuration));
    ```
2.  **인터페이스 순서 확인**: `mdc:./tinyusb-descriptors.mdc`에 정의된 인터페이스 순서(Keyboard → Mouse → CDC)가 올바른지 확인합니다.
3.  **VID/PID 확인**: `sdkconfig`와 Device Descriptor에 정의된 VID/PID가 일치하는지 확인합니다.

### 2.3. HID 리포트 전송 실패

**원인**: USB 버스가 준비되지 않았거나, 리포트 데이터 크기가 디스크립터와 일치하지 않습니다.

**디버깅 절차**:
1.  **USB 연결 상태 확인**: `tud_mounted()` 함수로 USB가 호스트에 연결 및 열거되었는지 확인합니다.
2.  **HID 준비 상태 확인**: `tud_hid_n_ready(instance)`가 `true`를 반환하는지 확인합니다. `false`일 경우, 이전 전송이 아직 완료되지 않았거나 연결이 끊긴 상태입니다.
3.  **리포트 크기 검증**: `sizeof(hid_keyboard_report_t)`가 8바이트, `sizeof(hid_mouse_report_t)`가 4바이트인지 `assert()` 등으로 확인합니다. `__attribute__((packed))`가 누락되지 않았는지 확인하십시오.

### 2.4. 태스크 워치독 타임아웃

**증상**: 시스템이 주기적으로 리셋되며, 로그에 "Task watchdog got triggered." 메시지가 출력됩니다.

**원인**: 특정 태스크가 장시간 블로킹되거나 무한 루프에 빠져 `esp_task_wdt_reset()`을 호출하지 못했습니다.

**해결책**:
- `uart_task`, `hid_task`, `usb_task` 등 워치독이 활성화된 모든 태스크의 `while(1)` 루프 내에 `esp_task_wdt_reset()` 호출이 포함되어 있는지 확인합니다.
- `vTaskDelay`나 `xQueueReceive` 같은 블로킹 함수 호출 전후의 로직이 너무 길지 않은지 검토합니다.

---

## 3. 구현 체크리스트

Phase 완료 전 아래 항목들을 점검하여 구현 누락을 방지합니다.

- [ ] **빌드**: `idf.py build`가 경고나 오류 없이 성공하는가?
- [ ] **디스크립터**: `usb_descriptors.c`에 4개의 필수 콜백이 모두 구현되었는가?
- [ ] **초기화**: `app_main`에서 `tud_init()`이 태스크 생성보다 먼저 호출되는가?
- [ ] **태스크**: `usb_task`가 `tud_task()`를 주기적으로 호출하며, 별도 코어(Core 1)에서 실행되는가?
- [ ] **동기화**: `uart_task`와 `hid_task` 간의 데이터 전달에 FreeRTOS 큐를 사용하는가?
- [ ] **USB 열거**: PC에 연결 시 Windows 장치 관리자 또는 `lsusb`에서 "BridgeOne USB Bridge"로 정상 인식되는가?
- [ ] **HID 동작**: 테스트 시 키보드 입력과 마우스 커서 이동이 정상적으로 동작하는가?
- [ ] **CDC 통신**: 시리얼 터미널로 CDC 포트에 연결하고 데이터를 송수신할 수 있는가?