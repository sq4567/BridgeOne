---
title: "TinyUSB 고급 기능 규칙"
description: "ESP-IDF 환경에서 BOS 디스크립터, 멀티 컨피규레이션, 커스텀 클래스 드라이버 등 TinyUSB의 고급 기능을 구현하는 방법을 정의합니다."
tags: ["tinyusb", "esp-idf", "advanced", "bos", "webusb", "winusb", "custom-driver"]
version: "v1.0"
owner: "Chatterbones"
updated: "2025-01-27"
framework: "ESP-IDF + TinyUSB"
references: ["Context7:/hathach/tinyusb", "mdc:./tinyusb-descriptors.mdc"]
---

# TinyUSB 고급 기능 구현 규칙

> **규칙 목적**: 표준 USB 클래스 기능을 넘어 WebUSB, WinUSB, 멀티 컨피규레이션, 커스텀 클래스 드라이버 등 TinyUSB가 제공하는 고급 기능들을 프로젝트에 통합하기 위한 표준 구현 방법을 정의합니다.

---

## 1. BOS (Binary Device Object Store) 디스크립터

**역할**: USB 2.1 사양부터 도입된 BOS 디스크립터는 디바이스의 핵심 기능 외에 추가적인 기능(Capability) 정보를 호스트에 제공합니다. 특히 WebUSB나 Microsoft OS 2.0 Descriptors (WinUSB)와 같은 플랫폼별 기능을 구현하는 데 필수적입니다.

### 1.1. `tud_descriptor_bos_cb()` 콜백 구현

이 콜백을 구현하여 BOS 디스크립터와 그 하위의 Capability 디스크립터들을 반환합니다.

```c
// usb_descriptors.c

// Microsoft OS 2.0 Descriptor 및 WebUSB를 위한 BOS Capability Descriptor
// VENDOR_REQUEST_* 매크로는 enum으로 별도 정의 필요
#define BOS_TOTAL_LEN      (TUD_BOS_DESC_LEN + TUD_BOS_WEBUSB_DESC_LEN + TUD_BOS_MICROSOFT_OS_DESC_LEN)
#define MS_OS_20_DESC_LEN  0xB2 // Microsoft OS 2.0 Descriptor Set의 전체 길이

uint8_t const desc_bos[] = {
    // 1. BOS Descriptor Header
    TUD_BOS_DESCRIPTOR(BOS_TOTAL_LEN, 2), // 2개의 Capability Descriptors 포함

    // 2. WebUSB Capability Descriptor (선택 사항)
    // 브라우저에서 디바이스에 접근할 수 있도록 허용하고, 랜딩 페이지 URL을 제공
    TUD_BOS_WEBUSB_DESCRIPTOR(VENDOR_REQUEST_WEBUSB, 1),

    // 3. Microsoft OS 2.0 Descriptors Platform Capability (선택 사항)
    // Windows Update를 통해 WinUSB 드라이버를 자동으로 설치하도록 유도
    TUD_BOS_MS_OS_20_DESCRIPTOR(MS_OS_20_DESC_LEN, VENDOR_REQUEST_MICROSOFT)
};

// BOS 디스크립터 콜백
uint8_t const* tud_descriptor_bos_cb(void) {
    return desc_bos;
}
```
**Context7 정보 (Trust Score 9.7)**: WebUSB와 Microsoft OS Descriptors는 독점적인 기능이므로, 이를 사용하려면 `idVendor`가 해당 업체에 의해 등록되어 있어야 합니다. 테스트 및 개발 목적으로는 문제가 없으나, 상용 제품에서는 USB-IF의 정책을 준수해야 합니다.

---

## 2. 멀티 컨피규레이션 (Multiple Configurations)

**역할**: 하나의 USB 디바이스가 여러 개의 동작 모드(Configuration)를 가질 수 있도록 지원합니다. 예를 들어, '표준 모드'와 '고속 충전 모드'를 별도의 컨피규레이션으로 분리하여 호스트가 선택할 수 있게 합니다.

### 2.1. `TUD_CONFIG_DESCRIPTOR` 매크로 수정

`TUD_CONFIG_DESCRIPTOR` 매크로의 첫 번째 인자는 컨피규레이션 번호(1-based)입니다. 여러 컨피규레이션을 정의하려면 각기 다른 번호로 디스크립터 배열을 생성해야 합니다.

```c
// usb_descriptors.c

// --- Configuration 1: HID + CDC (기본 모드) ---
uint8_t const desc_config_1[] = {
    TUD_CONFIG_DESCRIPTOR(1, ITF_NUM_TOTAL, 0, CONFIG_1_TOTAL_LEN,
                          TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 500),
    // ... HID, CDC 인터페이스 디스크립터 ...
};

// --- Configuration 2: VCP 전용 (펌웨어 업데이트 모드 등) ---
uint8_t const desc_config_2[] = {
    TUD_CONFIG_DESCRIPTOR(2, 2, 0, CONFIG_2_TOTAL_LEN,
                          TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP, 100),
    TUD_CDC_DESCRIPTOR(0, 0, EPNUM_CDC_NOTIF, 8, EPNUM_CDC_OUT, EPNUM_CDC_IN, 64)
};

// Device Descriptor의 bNumConfigurations 값을 2로 설정해야 함
// .bNumConfigurations = 2;

// tud_descriptor_configuration_cb 콜백에서 index에 따라 다른 디스크립터 반환
uint8_t const* tud_descriptor_configuration_cb(uint8_t index) {
    if (index == 0) {
        return desc_config_1;
    } else if (index == 1) {
        return desc_config_2;
    } else {
        return NULL;
    }
}
```
**설계 원칙**: 멀티 컨피규레이션은 호스트의 지원이 필요하며, 대부분의 OS는 첫 번째 컨피규레이션을 자동으로 선택합니다. 사용자가 직접 컨피규레이션을 변경하도록 유도하는 것은 복잡하므로, 특별한 목적(예: DFU 모드 진입)이 아니면 단일 컨피규레이션을 사용하는 것이 일반적입니다.

---

## 3. 커스텀 클래스 드라이버 (Custom Class Driver)

**역할**: TinyUSB가 공식적으로 지원하지 않는 USB 클래스나 독자적인 Vendor-Specific 프로토콜을 구현해야 할 때 사용합니다. TinyUSB 스택 코드를 직접 수정하지 않고 애플리케이션 레벨에서 새로운 클래스 드라이버를 추가할 수 있습니다.

### 3.1. `usbd_app_driver_get_cb()` 콜백 구현

TinyUSB는 초기화 과정에서 이 약한 심볼(weak symbol) 함수를 호출합니다. 이 함수가 유효한 드라이버 콜백 구조체 포인터를 반환하면, 해당 드라이버를 스택에 동적으로 추가합니다.

```c
// custom_driver.c

// 1. 커스텀 드라이버의 콜백 함수들 구현
static void custom_init(void);
static void custom_reset(uint8_t rhport);
static uint16_t custom_open(uint8_t rhport, tusb_desc_interface_t const * itf_desc, uint16_t max_len);
static bool custom_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const * request);
static bool custom_xfer_cb(uint8_t rhport, uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes);
static void custom_sof(uint8_t rhport);

// 2. 드라이버 콜백 구조체 정의
const usbd_class_driver_t custom_driver = {
#if CFG_TUSB_DEBUG >= 2
    .name = "CUSTOM",
#endif
    .init             = custom_init,
    .reset            = custom_reset,
    .open             = custom_open,
    .control_xfer_cb  = custom_control_xfer_cb,
    .xfer_cb          = custom_xfer_cb,
    .sof              = custom_sof,
};

// 3. TinyUSB가 호출할 콜백 함수 구현
const usbd_class_driver_t* usbd_app_driver_get_cb(uint8_t* driver_count) {
    *driver_count = 1; // 추가할 커스텀 드라이버의 수
    return &custom_driver;
}
```

**설계 원칙**:
- **독립성**: 커스텀 드라이버는 TinyUSB 스택과 독립적으로 개발 및 유지보수가 가능합니다.
- **복잡성**: USB 클래스 사양과 TinyUSB의 내부 동작에 대한 깊은 이해가 필요합니다. `open` 콜백에서 인터페이스 디스크립터를 파싱하고 엔드포인트를 여는(claiming) 로직이 핵심입니다.
- **Context7 정보 (Trust Score 9.7)**: 이 기능은 TinyUSB의 가장 강력한 확장 메커니즘 중 하나입니다. Raspberry Pi Pico SDK는 이 방식을 사용하여 독자적인 `Reset` 인터페이스를 구현했습니다. Host 측에서도 `usbh_app_driver_get_cb()`를 통해 동일한 방식으로 커스텀 드라이버를 추가할 수 있습니다.